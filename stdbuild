#pragma once

#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <filesystem>
#include <type_traits>
#include <cassert>

namespace std::build {

	void command(const std::string& cmd) {
		std::cout << "Running command: " << cmd << '\n';
		std::system(cmd.c_str());
	}

	////////////// Options //////////////

	namespace internal {
		struct Options {
			std::filesystem::path build_dir{ "build/" };
			std::filesystem::path bin_dir{ "bin/" };
			bool debug{ false };
		};

		template<typename T1, typename... T2>
		concept IsAllSame = std::conjunction_v<std::is_convertible<T2, T1>...>;
	}

	inline internal::Options& options() {
		static internal::Options opt;
		return opt;
	}

	inline void set_build_directory(std::filesystem::path path) {
		if (!std::filesystem::exists(path)) {
			std::filesystem::create_directory(path);
		}

		options().build_dir = path;
	}

	inline void set_bin_directory(std::filesystem::path path) {
		if (!std::filesystem::exists(path)) {
			std::filesystem::create_directory(path);
		}

		options().bin_dir = path;
	}

	inline void enable_debugging() {
		options().debug = true;
	}

	inline bool debug_enabled() {
		return options().debug;
	}

	enum class type : unsigned int { static_library, shared_library, executable };

	////////////// Version //////////////

	struct version {
		constexpr version() = default;
		constexpr version(uint32_t major, uint32_t minor, uint32_t patch) : m_major(major), m_minor(minor), m_patch(patch) {}
		uint32_t major() { return m_major; }
		const uint32_t major() const { return m_major; }
		uint32_t minor() { return m_minor; }
		const uint32_t minor() const { return m_minor; }
		uint32_t patch() { return m_patch; }
		const uint32_t patch() const { return m_patch; }
		constexpr bool operator>(const version& other) { return (m_major > other.m_major || m_minor > other.m_minor || m_patch > other.m_patch); }
		constexpr bool operator<(const version& other) { return (m_major < other.m_major || m_minor < other.m_minor || m_patch < other.m_patch); }
		constexpr bool operator==(const version& other) { return (m_major == other.m_major && m_minor == other.m_minor && m_patch == other.m_patch); }
		constexpr bool operator>=(const version& other) { return (m_major >= other.m_major && m_minor >= other.m_minor && m_patch >= other.m_patch); }
		constexpr bool operator<=(const version& other) { return (m_major <= other.m_major && m_minor <= other.m_minor && m_patch <= other.m_patch); }
	private:
		uint32_t m_major{ 0 }, m_minor{ 0 }, m_patch{ 0 };
	};

	////////////// Project //////////////

	class project {
	public:
		using build_type = type;
		using build_version = version;

	public:
		project(const std::string& name, build_type type) : m_name(name), m_type(type) {}
		project(const std::string& name) : m_name(name) {}

	public:
		std::vector<const project*>& dependencies() { return m_dependencies; }
		const std::vector<const project*>& dependencies() const { return m_dependencies; }

		std::string& name() { return m_name; }
		const std::string& name() const { return m_name; }

		std::filesystem::path directory() { return m_dir; }
		const std::filesystem::path directory() const { return m_dir; }

		build_type type() { return m_type; }
		const build_type type() const { return m_type; }

		build_version& version() { return m_version; }
		const build_version& version() const { return m_version; }

		std::vector<std::filesystem::path>& include_directories() { return m_include_dirs; }
		const std::vector<std::filesystem::path>& include_directories() const { return m_include_dirs; }

		std::vector<std::filesystem::path>& files() { return m_files; }
		const std::vector<std::filesystem::path>& files() const { return m_files; }

		std::vector<std::filesystem::path>& library_directories() { return m_library_dirs; }
		const std::vector<std::filesystem::path>& library_directories() const { return m_library_dirs; }

		std::vector<std::string>& flags() { return m_flags; }
		const std::vector<std::string>& flags() const { return m_flags; }

		std::vector<std::string>& libraries() { return m_libraries; }
		const std::vector<std::string>& libraries() const { return m_libraries; }

	public:
		template<typename... Files> requires internal::IsAllSame<std::string, Files...>
		friend void add_source_files(project& info, const Files&... files);
		friend void add_source_files(project& info, const std::vector<std::string>& files);

		template<typename... Flags> requires internal::IsAllSame<std::string, Flags...>
		friend void add_flags(project& info, const Flags&... flags);
		friend void add_flags(project& info, const std::vector<std::string>& flags);

		template<typename... IncludeDirs> requires internal::IsAllSame<std::string, IncludeDirs...>
		friend void add_include_directories(project& info, const IncludeDirs&... dirs);
		friend void add_include_directories(project& info, const std::vector<std::string>& dirs);

		template<typename... LibDirs> requires internal::IsAllSame<std::string, LibDirs...>
		friend void add_library_directories(project& info, const LibDirs&... dirs);
		friend void add_library_directories(project& info, const std::vector<std::string>& dirs);

		template<typename... Libs> requires internal::IsAllSame<std::string, Libs...>
		friend void add_libraries(project& info, const Libs&... libs);
		friend void add_libraries(project& info, const std::vector<std::string>& libs);

		template<typename... Dependencies> requires internal::IsAllSame<const project&, Dependencies...>
		friend void add_dependencies(project& info, const Dependencies&... depends);

		friend void set_directory(project& info, std::filesystem::path directory);

		friend void set_type(project& info, build_type new_type);

		friend void set_version(project& info, const build_version& ver);

	private:
		std::vector<const project*> m_dependencies;
		std::string m_name;
		std::filesystem::path m_dir{ "." };
		build_type m_type{ build_type::executable };
		build_version m_version;
		std::vector<std::filesystem::path> m_include_dirs, m_files, m_library_dirs;
		std::vector<std::string> m_flags, m_libraries;
	};

	template<typename... Files> requires internal::IsAllSame<std::string, Files...>
	void add_source_files(project& info, const Files&... files) { (info.m_files.push_back(files), ...); }
	void add_source_files(project& info, const std::vector<std::string>& files) { info.m_files.insert(info.m_files.end(), files.begin(), files.end()); }

	template<typename... Flags> requires internal::IsAllSame<std::string, Flags...>
	void add_flags(project& info, const Flags&... flags) { (info.m_flags.push_back(flags), ...); }
	void add_flags(project& info, const std::vector<std::string>& flags) { info.m_flags.insert(info.m_flags.end(), flags.begin(), flags.end()); }

	template<typename... IncludeDirs> requires internal::IsAllSame<std::string, IncludeDirs...>
	void add_include_directories(project& info, const IncludeDirs&... dirs) { (info.m_include_dirs.push_back(dirs), ...); }
	void add_include_directories(project& info, const std::vector<std::string>& dirs) { info.m_include_dirs.insert(info.m_include_dirs.end(), dirs.begin(), dirs.end()); }

	template<typename... LibDirs> requires internal::IsAllSame<std::string, LibDirs...>
	void add_library_directories(project& info, const LibDirs&... dirs) { (info.m_library_dirs.push_back(dirs), ...); }
	void add_library_directories(project& info, const std::vector<std::string>& dirs) {info.m_library_dirs.insert(info.m_library_dirs.end(), dirs.begin(), dirs.end());}

	template<typename... Libs> requires internal::IsAllSame<std::string, Libs...>
	void add_libraries(project& info, const Libs&... libs) { (info.m_libraries.push_back(libs), ...); }
	void add_libraries(project& info, const std::vector<std::string>& libs) { info.m_libraries.insert(info.m_libraries.end(), libs.begin(), libs.end()); }

	template<typename... Dependencies> requires internal::IsAllSame<const project&, Dependencies...>
	void add_dependencies(project& info, const Dependencies&... depends) { (info.m_dependencies.push_back(&depends), ...); }

	void set_directory(project& info, std::filesystem::path directory) { info.m_dir = directory; }

	void set_type(project& info, type new_type) { info.m_type = new_type; }

	void set_version(project& info, const version& ver) { info.m_version = ver; }

	////////////// Library //////////////

	struct Library {
	public:
		using build_type = type;

	public:
		Library(std::filesystem::path location, std::filesystem::path file_name, build_type type) : m_location(location), m_file_name(file_name), m_type(type) {}

		const std::filesystem::path location() const { return m_location; }

		const std::filesystem::path file_name() const { return m_file_name; }

		const build_type type() const { return m_type; }

	private:
		std::filesystem::path m_location;
		std::filesystem::path m_file_name;
		build_type m_type;
	};

	////////////// Compilation //////////////

	inline std::vector<std::filesystem::path> compile(const project& info) {
		auto build_dir = options().build_dir / info.name();

		if (!std::filesystem::exists(build_dir)) {
			std::filesystem::create_directory(build_dir);
		}

		std::vector<std::filesystem::path> obj_files;

		for (const auto& f : info.files()) {
			std::stringstream output;
			output << "g++ -c ";
			for (const auto& f : info.flags()) { output << f << ' '; }
			for (const auto& i : info.include_directories()) { output << "-I" << i << ' '; }
			output << info.directory() / f;
			auto obj_path = (build_dir / f.stem()).replace_extension(".o");
			output << " -o " << obj_path;
			obj_files.push_back(std::move(obj_path));
			command(output.str());
		}

		return obj_files;
	}

	////////////// Create Binaries //////////////

	inline Library create_static_library(const project& info) {
		std::cout << "\nCreating static library: " << info.name() << '\n';
		auto bin_dir = options().bin_dir;

		if (!std::filesystem::exists(bin_dir)) {
			std::filesystem::create_directory(bin_dir);
		}

		std::cout << "\tCompiling...\n\t";
		auto objs = compile(info);

		auto file = std::filesystem::path("lib" + info.name()).replace_extension(".a");
		std::cout << "\tOutput directory: " << bin_dir << '\n';
		std::cout << "\tOutput file name: " << file << '\n';

		std::cout << "\tLinking...\n";
		std::stringstream output;
		output << "ar rcs " << bin_dir / file << ' ';
		for (const auto& obj : objs) {
			output << obj << ' ';
		}
		std::cout << '\t';
		command(output.str());

		return Library(bin_dir, std::filesystem::path(info.name()), std::build::type::static_library);
	}

	inline void create_executable(project& info) {

		std::cout << "Creating executable: " << info.name() << "\n";
		auto bin_dir = options().bin_dir;

		if (!std::filesystem::exists(bin_dir)) {
			std::filesystem::create_directory(bin_dir);
		}

		// Transform include & library directories by prepending the project's working directory
		for (auto& id : info.include_directories()) { id = info.directory() / id; }
		for (auto& ld : info.library_directories()) { ld = info.directory() / ld; }

		auto dependencies = info.dependencies();
		if (dependencies.size() > 0) {
			std::cout << "Building dependencies.\n";
			for (auto& dependency : dependencies) {
				auto lib = create_static_library(*dependency);
				info.library_directories().push_back(lib.location());
				info.libraries().push_back(lib.file_name().string());
				for (const auto& inc : dependency->include_directories()) {
					info.include_directories().push_back(dependency->directory() / inc);
				}
			}
		}

		if (info.files().size() > 0) {
			std::cout << "Compiling...\n";
			auto objs = compile(info);

			std::cout << "Linking...\n";
			std::stringstream output;
			output << "g++ ";
			for (const auto& obj : objs) {
				output << obj << " ";
			}
			output << " -o " << (bin_dir / info.name()) << ' ';
			for (const auto& ld : info.library_directories()) { output << "-L" << ld << ' '; }
			for (const auto& l : info.libraries()) { output << "-l" << l << ' '; }
			command(output.str());
		}
	}
}