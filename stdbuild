#pragma once

#include <filesystem>
#include <iostream>
#include <map>
#include <sstream>
#include <string>
#include <vector>
#include <optional>
#include <fstream>
#include <algorithm>
#include <unordered_map>
#include <type_traits>
#include <utility>

#define _STD_BUILD std::build
#define _STD_BUILD_OUTPUT(str) std::cout << str;

#ifdef _STD_BUILD_VERBOSE
#define _STD_BUILD_VERBOSE_OUTPUT(str) std::cout << str
#else
#define _STD_BUILD_VERBOSE_OUTPUT(str)
#endif

#if defined(_MSC_VER)
#define _STD_BUILD_COMPILER "cl"
#elif defined(__GNUC__)
#define _STD_BUILD_COMPILER "g++"
#elif defined(__clang__)
#define _STD_BUILD_COMPILER "clang"
#else
#error A supported compiler (msvc, g++, clang) must be used.
#endif

#ifdef _STD_BUILD_DONT_EXIT_ON_FAILURE
#define _STD_BUILD_FAILURE_RETURN() return false
#else
#define _STD_BUILD_FAILURE_RETURN() \
	std::exit(1);                   \
	return false
#endif

#define _STD_BUILD_FAILURE() std::exit(1);

// TODO: Disable cache flag. (maybe a option)

#if __cplusplus < 201703L
#error C++17 is needed for filesystem support.
#endif

namespace _STD_BUILD {

	enum class library_type : uint8_t { STATIC, SHARED, HEADER };

	inline const library_type static_library = library_type::STATIC;
	inline const library_type shared_library = library_type::SHARED;
	inline const library_type header_library = library_type::HEADER;

	namespace fs = std::filesystem;
	using path = fs::path;

	////////////// Options //////////////

	struct _Options {
		fs::path build_dir{ "build/" };
		fs::path bin_dir{ "bin/" };
		std::string output_redirect_str{ " 2>build/error" }; //">build/output 2>build/error" };
		// std::string output_file{ "build/output" };
		std::string error_file{ "build/error" };
		bool debug{ false };

		void set(const std::string& opt, bool value) { _user_defined_opts[opt] = value; }
		bool get(const std::string& opt) { return _user_defined_opts[opt]; }

	private:
		std::map<std::string, bool> _user_defined_opts;
	};

	inline _Options& options() {
		static _Options opt;
		return opt;
	}

	inline void set_build_directory(fs::path path) {
		if (!fs::exists(path)) {
			fs::create_directory(path);
		}

		options().build_dir = path;
		// options().output_file = (path / "output").string();
		options().error_file = (path / "error").string();
		options().output_redirect_str = " 2>" + options().error_file;
		//">" + options().output_file + " 2>" + options().error_file;
	}

	inline void set_bin_directory(fs::path path) {
		if (!fs::exists(path)) {
			fs::create_directory(path);
		}

		options().bin_dir = path;
	}

	inline void set_option(const std::string& opt, bool value) { options().set(opt, value); }

	inline bool get_option(const std::string& opt) { return options().get(opt); }

	inline void enable_debugging() { options().debug = true; }

	inline void disable_debugging() { options().debug = false; }

	inline bool debugging_enabled() { return options().debug; }

	////////////// Error Handling //////////////

	void _print_error_log() {
		std::ifstream error(options().error_file);
		if (error) {
			std::cout << error.rdbuf();
			error.close();
		}
	}

	////////////// Command //////////////

	int command(const std::string& cmd) {
		_STD_BUILD_VERBOSE_OUTPUT("Running command: " << cmd << '\n');
		return std::system((cmd + options().output_redirect_str).c_str());
	}

	////////////// Version //////////////

	struct version {
		version() = default;
		version(uint32_t major, uint32_t minor, uint32_t patch) : m_major(major), m_minor(minor), m_patch(patch) {}

		uint32_t major() { return m_major; }
		uint32_t major() const { return m_major; }
		uint32_t minor() { return m_minor; }
		uint32_t minor() const { return m_minor; }
		uint32_t patch() { return m_patch; }
		uint32_t patch() const { return m_patch; }

		bool operator>(const version& other) const {
			return (m_major > other.m_major || m_minor > other.m_minor || m_patch > other.m_patch);
		}

		bool operator<(const version& other) const {
			return (m_major < other.m_major || m_minor < other.m_minor || m_patch < other.m_patch);
		}

		bool operator==(const version& other) const {
			return (m_major == other.m_major && m_minor == other.m_minor && m_patch == other.m_patch);
		}

		bool operator!=(const version& other) const { return !(*this == other); }

		bool operator>=(const version& other) const { return (*this > other || *this == other); }

		bool operator<=(const version& other) const { return (*this < other || *this == other); }

	private:
		uint32_t m_major{ 0 }, m_minor{ 0 }, m_patch{ 0 };
	};

	////////////// List //////////////

	// all = public, parent = interface, self = private
	enum class access : uint8_t { all, parent, self };

	template <typename Type>
	class list_base {
	private:
		template <typename _Type, typename Stream, typename = void>
		struct is_streamable : std::false_type {};

		template <typename _Type, typename Stream>
		struct is_streamable<_Type, Stream, std::void_t<decltype(std::declval<Stream&>() << std::declval<_Type>())>>
		    : std::true_type {};

	public:
		list_base() = default;
		list_base(const Type&) = delete;
		list_base(const list_base<Type>& list) : m_items(list.m_items) {}
		list_base(list_base<Type>&& list) noexcept {
			if (this != &list) {
				m_items = std::move(list.m_items);
			}
		}
		list_base(const std::initializer_list<Type>& elements) {
			m_items.insert(m_items.end(), elements.begin(), elements.end());
		}

		/// Misc Functions ///

		std::vector<Type>& get() { return m_items; }
		const std::vector<Type>& get() const { return m_items; }
		std::size_t size() const { return m_items.size(); }
		std::size_t size() { return m_items.size(); }
		void add(const Type& item) { m_items.push_back(item); }

		// TODO: improve this
		template <typename _Type = Type>
		auto string(unsigned char delim = ' ') const
		    -> std::enable_if_t<is_streamable<Type, std::ostream>::value, _Type> {
			if (m_items.size() > 0) {
				std::ostringstream ss;
				for (const auto& item : m_items) {
					ss << item << delim;
				}
				auto str = std::move(ss.str());
				str.erase(str.end() - 1); // Removes the last delimiter from the string
				return str;
			}
			return "";
		}

		/// Operators ///

		list_base<Type>& operator=(const list_base<Type>& list) {
			if (this != &list) {
				m_items = list.m_items;
			}
			return *this;
		}

		list_base<Type>& operator=(list_base<Type>&& list) {
			if (this != &list) {
				m_items = std::move(list.m_items);
			}
			return *this;
		}

		void operator+=(const Type& item) { add(item); }

		void operator+=(const list_base<Type>& list) {
			m_items.insert(m_items.end(), list.m_items.begin(), list.m_items.end());
		}

		list_base<Type> operator+(const list_base<Type>& other) {
			list_base<Type> copy;
			copy.get() = m_items;
			copy.get().insert(copy.get().end(), other.get().begin(), other.get().end());
			return copy;
		}

		/// Iterator Functions ///

		auto begin() { return m_items.begin(); }
		const auto begin() const { return m_items.begin(); }
		auto end() { return m_items.end(); }
		const auto end() const { return m_items.end(); }

		/// Stream Functions ///
		friend std::ostream& operator<<(std::ostream& stream, const list_base<Type>& list) {
			for (const auto& item : list.get()) {
				stream << item << ' ';
			}
			return stream;
		}

	private:
		std::vector<Type> m_items;
	};

	template <typename Type>
	struct ListElement {
		Type value;
		access access_level{ access::self };

		ListElement(const Type& _value) : value(_value) {}
		ListElement(const Type& _value, access _access_level) : value(_value), access_level(_access_level) {}

		template <typename Type2>
		    requires std::is_convertible_v<Type2, Type>
		ListElement(const Type2& _value) : value(_value) {}

		template <typename Type2>
		    requires std::is_convertible_v<Type2, Type>
		ListElement(const Type2& _value, access _access_level) : value(_value), access_level(_access_level) {}

		bool operator<(const ListElement<Type>& other) const { return value < other.value; }

		bool operator==(const ListElement<Type>& other) const {
			return (value == other.value && access_level == other.access_level);
		}

		friend std::ostream& operator<<(std::ostream& stream, const ListElement& element) {
			stream << element.value << ' ';
			return stream;
		}
	};

	// TODO: Change this to path_list
	using string_list = list_base<ListElement<std::string>>;
	using path_list = list_base<ListElement<fs::path>>;

	////////////// Cache //////////////

	namespace __cache {
		namespace serialization {

			void write_string(std::ofstream& stream, const std::string& str) {
				const std::size_t size = str.size();
				stream.write(reinterpret_cast<const char*>(&size), sizeof(std::size_t));
				stream.write(str.data(), size);
			}

			void read_string(std::ifstream& stream, std::string& str) {
				std::size_t size{ 0 };
				stream.read(reinterpret_cast<char*>(&size), sizeof(std::size_t));
				str.resize(size);
				stream.read(str.data(), size);
			}

			void write_int64_t(std::ofstream& stream, const int64_t i) {
				stream.write(reinterpret_cast<const char*>(&i), sizeof(int64_t));
			}
			void read_int64_t(std::ifstream& stream, int64_t& i) {
				stream.read(reinterpret_cast<char*>(&i), sizeof(int64_t));
			}
			void write_size_t(std::ofstream& stream, const std::size_t i) {
				stream.write(reinterpret_cast<const char*>(&i), sizeof(std::size_t));
			}
			void read_size_t(std::ifstream& stream, std::size_t& i) {
				stream.read(reinterpret_cast<char*>(&i), sizeof(std::size_t));
			}

		} // namespace serialization

		const std::string cache_file_id{ "STDBUILD" };

		const std::vector<std::string> std_header_files = { "bitset",
			                                                "chrono",
			                                                "compare",
			                                                "csetjmp",
			                                                "csignal",
			                                                "cstdarg",
			                                                "cstddef",
			                                                "cstdlib",
			                                                "ctime",
			                                                "expected",
			                                                "functional",
			                                                "initializer_list",
			                                                "optional",
			                                                "source_location",
			                                                "tuple",
			                                                "type_traits",
			                                                "typeindex",
			                                                "typeinfo",
			                                                "utility",
			                                                "variant",
			                                                "version",
			                                                "memory",
			                                                "memory_resource",
			                                                "new",
			                                                "scoped_allocator",
			                                                "cfloat",
			                                                "cinttypes",
			                                                "climits",
			                                                "cstdint",
			                                                "limits",
			                                                "stdfloat",
			                                                "cassert",
			                                                "cerrno",
			                                                "exception",
			                                                "stacktrace",
			                                                "stdexcept",
			                                                "system_error",
			                                                "cctype",
			                                                "charconv",
			                                                "cstring",
			                                                "cuchar",
			                                                "cwchar",
			                                                "cwctype",
			                                                "format",
			                                                "string",
			                                                "string_view",
			                                                "array",
			                                                "deque",
			                                                "flat_map",
			                                                "flat_set",
			                                                "forward_list",
			                                                "list",
			                                                "map",
			                                                "mdspan",
			                                                "queue",
			                                                "set",
			                                                "span",
			                                                "stack",
			                                                "unordered_map",
			                                                "unordered_set",
			                                                "vector",
			                                                "iterator",
			                                                "generator",
			                                                "ranges",
			                                                "algorithm",
			                                                "execution",
			                                                "bit",
			                                                "cfenv",
			                                                "cmath",
			                                                "complex",
			                                                "numbers",
			                                                "numeric",
			                                                "random",
			                                                "ratio",
			                                                "valarray",
			                                                "clocale",
			                                                "codecvt",
			                                                "locale",
			                                                "cstdio",
			                                                "fstream",
			                                                "iomanip",
			                                                "ios",
			                                                "iosfwd",
			                                                "iostream",
			                                                "istream",
			                                                "ostream",
			                                                "print",
			                                                "spanstream",
			                                                "sstream",
			                                                "streambuf",
			                                                "strstream",
			                                                "syncstream",
			                                                "filesystem",
			                                                "regex",
			                                                "atomic",
			                                                "barrier",
			                                                "condition_variable",
			                                                "future",
			                                                "latch",
			                                                "mutex",
			                                                "semaphore",
			                                                "shared_mutex",
			                                                "stop_token",
			                                                "thread",
			                                                "ctype.h",
			                                                "errno.h",
			                                                "fenv.h",
			                                                "float.h",
			                                                "inttypes.h",
			                                                "limits.h",
			                                                "locale.h",
			                                                "math.h",
			                                                "setjmp.h",
			                                                "signal.h",
			                                                "stdarg.h",
			                                                "stddef.h",
			                                                "stdint.h",
			                                                "stdio.h",
			                                                "stdlib.h",
			                                                "string.h",
			                                                "time.h",
			                                                "uchar.h",
			                                                "wchar.h",
			                                                "wctype.h",
			                                                "stdatomic.h",
			                                                "ccomplex",
			                                                "complex.h",
			                                                "ctgmath",
			                                                "tgmath.h",
			                                                "ccomplex",
			                                                "complex.h",
			                                                "ctgmath",
			                                                "tgmath.h",
			                                                "assert.h",
			                                                "crtdbg.h",
			                                                "Windows.h" };

		// Returns the file's last write time since epoch in seconds
		inline int64_t get_lwt(const fs::path& file) noexcept {
			const auto lwt = fs::last_write_time(file);

// This two methods of converting lwt to an integer produce very different results.
// The first one that only works after C++20 produces the correct result.
// The second that works on C++17 produces a passable result, but is negative
// and does not relate to the correct epoch time.
#if __cpp_lib_chrono >= 201907L
			return std::chrono::system_clock::to_time_t(std::chrono::clock_cast<std::chrono::system_clock>(lwt));
#elif __cpp_lib_chrono >= 201611L
			return std::chrono::duration_cast<std::chrono::seconds>(lwt.time_since_epoch()).count();
#else
#endif
		}

		struct lwt_file_block {
			fs::path path;
			int64_t lwt{ 0 };
			path_list dependent_files;

			lwt_file_block() = default;
			lwt_file_block(const fs::path _path) : path(_path) { lwt = get_lwt(_path); }
			lwt_file_block(const fs::path _path, int64_t _lwt) : path(_path), lwt(_lwt) {}
			lwt_file_block(const fs::path _path, int64_t _lwt, const path_list& _dependent_files)
			    : path(_path), lwt(_lwt), dependent_files(_dependent_files) {}

			void reload_lwt() { lwt = get_lwt(path); }

			operator ListElement<fs::path>() { return ListElement<fs::path>{ path }; }
			bool operator==(const ListElement<fs::path>& file) { return (path == file.value); }
			friend bool operator==(const ListElement<fs::path>& file, const lwt_file_block& lwtfb) {
				return (file.value == lwtfb.path);
			}
			bool operator<(const ListElement<fs::path>& file) { return (path < file.value); }
			friend bool operator<(const ListElement<fs::path>& file, const lwt_file_block& lwtfb) {
				return (file.value < lwtfb.path);
			}

			friend std::ofstream& operator<<(std::ofstream& stream, const lwt_file_block& block) {
				serialization::write_string(stream, block.path.string());
				serialization::write_int64_t(stream, block.lwt);

				// write the source files that depend on this header
				serialization::write_size_t(stream, block.dependent_files.size());

				// iterate through list of dependent files and write their paths out
				for (const auto& source : block.dependent_files) {
					serialization::write_string(stream, source.value.string());
				}

				return stream;
			}

			friend std::ifstream& operator>>(std::ifstream& stream, lwt_file_block& block) {
				// read the path
				std::string path;
				serialization::read_string(stream, path);
				block.path = { path };
				// read the "last write time"
				serialization::read_int64_t(stream, block.lwt);

				// read in the number of source files for this header
				std::size_t source_file_count{ 0 };
				serialization::read_size_t(stream, source_file_count);
				block.dependent_files.get().reserve(source_file_count);

				for (std::size_t i = 0; i < source_file_count; ++i) {
					std::string source_path;
					serialization::read_string(stream, source_path);
					block.dependent_files.get().push_back({ source_path });
				}

				return stream;
			}
		};

		std::optional<fs::path> find_file(const path_list& include_directories,
		                                  const fs::path& parent_dir,
		                                  const fs::path& file) {
			if (fs::exists(file)) {
				return file;
			}
			if (fs::exists(parent_dir / file)) {
				return parent_dir / file;
			}

			for (const auto& dir : include_directories) {
				const auto prepended_file_loc = dir.value / file;
				if (fs::exists(prepended_file_loc)) {
					return prepended_file_loc;
				}
			}

			return std::nullopt;
		};

		template <typename _InIt, typename _InIt2, typename _OutIt>
		void find_differences(const _InIt begin1,
		                      const _InIt end1,
		                      const _InIt2 begin2,
		                      const _InIt2 end2,
		                      _OutIt add,
		                      _OutIt sub) {
			for (_InIt temp = begin1; temp != end1; ++temp) {
				if (std::find(begin2, end2, *temp) == end2) {
					*add++ = *temp;
				}
			}

			for (_InIt2 temp = begin2; temp != end2; ++temp) {
				if (std::find(begin1, end1, *temp) == end1) {
					*sub++ = *temp;
				}
			}
		}

		path_list get_includes_unsorted(const path_list& include_directories, const fs::path& file_name) {
			const fs::path parent_dir = file_name.parent_path();

			path_list includes;

			const auto is_standard_library_header = [&](const std::string& file) -> bool {
				return (std::find(std_header_files.begin(), std_header_files.end(), file) != std_header_files.end());
			};

			std::ifstream file(file_name);
			if (file.is_open()) {

				std::string line;
				while (std::getline(file, line)) {

					if (line.starts_with("#include")) {
						line =
						    line.substr(8 + (line.at(8) == ' ' ?
						                         1 :
						                         0)); // remove "#include", and if it exists, remove whitespace after it
						line = line.substr(1, line.size() - 2); // remove the <> or ""

						// check if the include file is part of the standard library or not
						if (!is_standard_library_header(line)) {
							if (auto file_path = find_file(include_directories, parent_dir, fs::path(line))) {

								const fs::path clean_path = file_path.value().lexically_normal();
								includes.get().push_back(clean_path);

								// Check if the dependency has dependencies.
								for (const auto& sub_include_path :
								     get_includes_unsorted(include_directories, clean_path)) {
									includes.get().push_back(sub_include_path);
								}
							}
						}
					}
				}

				file.close();
			}

			return includes;
		}

		path_list get_includes(const path_list& include_directories, const fs::path& file_name) {
			// get list of includes for each cpp file that are unsorted and contains duplicates
			path_list unsorted_includes = std::move(get_includes_unsorted(include_directories, file_name));
			auto& data = unsorted_includes.get();

			// Sort and remove duplicates
			std::sort(data.begin(), data.end());
			data.erase(std::unique(data.begin(), data.end()), data.end());
			return unsorted_includes;
		}

		struct cache_storage {
		private:
			struct cache_changes {
				path_list added, removed, modified;
			};

		public:
			std::vector<lwt_file_block> source_files;
			std::vector<lwt_file_block> header_files;
			cache_changes changes;

			void write_to_file(const fs::path& file_path) {
				std::ofstream cache_file(file_path.string(), std::ios::binary);
				if (cache_file.is_open()) {
					// Write file identification code.
					serialization::write_string(cache_file, cache_file_id);
					cache_file << *this;
					cache_file.close();
				}
			}

			bool load_from_file(const fs::path& file_path) {
				std::ifstream cache_file(file_path.string(), std::ios::binary);
				if (cache_file.is_open()) {

					// Read and verify identification code.
					std::string id;
					serialization::read_string(cache_file, id);
					if (id != cache_file_id) {
						return false;
					}

					cache_file >> *this;

					return true;
					cache_file.close();
				}
				return false;
			}

			void check_for_file_changes() {
				auto& data = changes.modified.get();

				for (const auto& source : source_files) {
					if (get_lwt(source.path) > source.lwt) {
						data.push_back(source.path);
					}
				}

				for (const auto& header : header_files) {
					if (get_lwt(header.path) > header.lwt && header.dependent_files.size() > 0) {
						data.insert(data.end(), header.dependent_files.begin(), header.dependent_files.end());
					}
				}

				// Sort and remove any duplicates
				std::sort(data.begin(), data.end());
				data.erase(std::unique(data.begin(), data.end()), data.end());
			}

			// TODO: This is horrible. Clean it up.
			//  To update the cache we need to deal with the following: modified/added/removed source files.
			void update(const path_list& include_dirs) {
				for (const auto& modded_file : changes.modified) {
					// Verify that the modded file does exist in our cache source file list.
					const auto it = std::find(source_files.begin(), source_files.end(), modded_file);
					if (it != source_files.end()) {
						// If the file is present, then rebuild the include hierarchy.
						(*it).dependent_files = get_includes(include_dirs, (*it).path);
						(*it).reload_lwt();

						// We need to make sure that all the header files have this source file as one of their
						// dependents.
						for (const auto& dep_header : (*it).dependent_files) {
							// Check if this header already exists in the cache header list.
							auto it = std::find(header_files.begin(), header_files.end(), dep_header);
							if (it != header_files.end()) {
								// If it does then check if this header has the source in its dependency list.
								auto it2 =
								    std::find((*it).dependent_files.begin(), (*it).dependent_files.end(), modded_file);
								if (it2 == (*it).dependent_files.end()) {
									// File doesn't exist in the headers dependency list, so add it.
									(*it).dependent_files.add(modded_file);
								}
							} else {
								header_files.push_back(
								    { dep_header.value, get_lwt(dep_header.value), { modded_file } });
							}
						}
					}
				}

				// For each of the newly added source files:
				for (const auto& new_file : changes.added) {
					// Verify whether the modded file exists in our cache source file list.
					const auto it = std::find(source_files.begin(), source_files.end(), new_file);
					if (it != source_files.end()) {
						// If the file is present, then rebuild the include hierarchy.
						(*it).dependent_files = get_includes(include_dirs, (*it).path);
						(*it).reload_lwt();
					} else {
						// If not, then add it to the source list.
						source_files.push_back({ new_file.value });
					}
				}

				// For every source file that was removed:
				for (const auto& removed_file : changes.removed) {
					// Check to see if it exists in the cache source file list.
					const auto it = std::find(source_files.begin(), source_files.end(), removed_file);
					if (it != source_files.end()) {
						// If it exists, iterate through the dependent headers and remove the source file from their
						// depednency lists
						for (const auto& header : (*it).dependent_files) {
							const auto it2 = std::find(header_files.begin(), header_files.end(), header);
							if (it2 != header_files.end()) {
								const auto it3 = std::find((*it2).dependent_files.begin(), (*it2).dependent_files.end(),
								                           removed_file);
								if (it3 != (*it2).dependent_files.end()) {
									(*it2).dependent_files.get().erase(it3);
								}
							}
						}
						source_files.erase(it);
					}
				}
			}

			void test(const path_list& cpp_files) {
				find_differences(cpp_files.begin(), cpp_files.end(), source_files.begin(), source_files.end(),
				                 std::back_inserter(changes.added.get()), std::back_inserter(changes.removed.get()));
				check_for_file_changes();
			}

			friend std::ofstream& operator<<(std::ofstream& stream, const cache_storage& cache) {
				// Write source file last write times
				serialization::write_size_t(stream, cache.source_files.size());
				for (const auto& source_file : cache.source_files) {
					stream << source_file;
				}
				// Write header file last write times
				serialization::write_size_t(stream, cache.header_files.size());
				for (const auto& header_file : cache.header_files) {
					stream << header_file;
				}

				return stream;
			}

			friend std::ifstream& operator>>(std::ifstream& stream, cache_storage& cache) {
				// Read in the source files
				std::size_t source_file_count{ 0 };
				serialization::read_size_t(stream, source_file_count);
				cache.source_files.reserve(source_file_count);
				for (std::size_t i = 0; i < source_file_count; ++i) {
					lwt_file_block temp;
					stream >> temp;
					cache.source_files.push_back(std::move(temp));
				}

				// Read in the header files
				std::size_t header_file_count{ 0 };
				serialization::read_size_t(stream, header_file_count);
				cache.header_files.reserve(header_file_count);
				for (std::size_t i = 0; i < header_file_count; ++i) {
					lwt_file_block temp;
					stream >> temp;
					cache.header_files.push_back(std::move(temp));
				}

				return stream;
			}

			friend std::ostream& operator<<(std::ostream& stream, const cache_storage& cache) {
				stream << "\n------------------------------\n";
				stream << "Cache:\n";
				stream << "Source files:\n";
				for (const auto& source_file : cache.source_files) {
					stream << '\t' << source_file.path.string() << '\n';
					for (const auto& dep : source_file.dependent_files) {
						stream << "\t\t" << dep.value.string() << '\n';
					}
				}
				stream << "Header files:\n";
				for (const auto& header_file : cache.header_files) {
					stream << '\t' << header_file.path.string() << '\n';
					for (const auto& dep : header_file.dependent_files) {
						stream << "\t\t" << dep.value.string() << '\n';
					}
				}

				stream << "Added:\n";
				for (const auto& added : cache.changes.added) {
					stream << '\t' << added << '\n';
				}

				stream << "Removed:\n";
				for (const auto& removed : cache.changes.removed) {
					stream << '\t' << removed << '\n';
				}

				stream << "Modified:\n";
				for (const auto& modified : cache.changes.modified) {
					stream << '\t' << modified << '\n';
				}
				stream << "------------------------------\n";
				return stream;
			}
		};

		cache_storage build(const path_list& include_directories, const path_list& cpp_files) {
			std::unordered_map<fs::path, path_list> cpp_file_dependencies;
			for (const auto& file : cpp_files) {
				// Iterate through every file and verify it exists.
				if (fs::exists(file.value)) {
					// Clean up the slashes uses lexically normal.
					const auto lexically_normal_file_path = file.value.lexically_normal();

					// Recursively get all the header files associated with this source file and add them to the source
					// files dependents list.
					cpp_file_dependencies[lexically_normal_file_path] =
					    get_includes(include_directories, lexically_normal_file_path);
				} else {
					_STD_BUILD_OUTPUT("File " << file.value << " was not found and cannot be added to the cache.\n");
				}
			}

			// Invert the dependency tree, so that we have a list of header files that contains the source files that
			// depend on them. By checking for a change in a header, we can know which source files need to be
			// recompiled because of that change.
			std::unordered_map<fs::path, path_list> headers;

			for (const auto& [cpp_file, dependencies] : cpp_file_dependencies) {
				for (const auto& dep : dependencies) {
					auto& hv = headers[dep.value];
					if (std::find(hv.begin(), hv.end(), cpp_file) == hv.end()) {
						hv.get().push_back(cpp_file);
					}
				}
			}

			cache_storage cache;

			for (const auto& source : cpp_files) {
				cache.source_files.push_back({ source.value.lexically_normal() });
			}

			for (const auto& header : headers) {
				cache.header_files.push_back({ header.first, get_lwt(header.first), header.second });
			}

			return cache;
		}

		inline bool cache_exists(const fs::path& file_path) { return fs::exists(file_path); }

		// The initialize_cache method is to be called at the start of every build.
		// It needs to check if a cache file already exists, and if not, then take the
		// include directories/cpp_files, and build the cache for the first time with them.
		// If the function returns true, then the cache exists and we can load it.
		// If it returns false, the cache was just created and all the cpp files need to be compiled.
		// TODO: A cache needs to be built for every package, so this needs to be called at the top of every
		// create_library/create_executable.
		// Return: true if cache was initialized, false is a cache already exists
		std::pair<bool, cache_storage> initialize_cache(const fs::path& cache_file_path,
		                                                const path_list& include_directories,
		                                                const path_list& cpp_files) {
			if (cache_exists(cache_file_path) == false) {
				_STD_BUILD_OUTPUT("file not found, creating new cache...");
				auto cache = build(include_directories, cpp_files);
				cache.write_to_file(cache_file_path);
				_STD_BUILD_OUTPUT("complete.\n");
				return { true, cache };
			}
			return { false, {} };
		}
	} // namespace __cache

	////////////// Package //////////////

	struct package;
	using package_list = list_base<package>;

	struct package {
		package() = default;
		explicit package(const std::string& _name) : name(_name) {}
		string_list flags, libraries;
		path_list include_dirs, library_dirs, sources;
		package_list pkgs;
		version ver{ 0, 0, 0 };
		std::string name{ "package" };
		path dir{ "." };
		library_type type{ static_library };
	};

	////////////// Library //////////////

	struct _Library_Output {
		fs::path location;
		fs::path name;
		library_type type{ static_library };
		_Library_Output(fs::path _location, fs::path _name, library_type _type)
		    : location(_location), name(_name), type(_type) {}
	};

	////////////// Compilation //////////////

	using _Dependency_Vec = std::vector<package*>;

	inline void _add_packages(_Dependency_Vec& dep, package& project) {
		for (auto& pkg : project.pkgs) {
			dep.push_back(&pkg);
			_add_packages(dep, pkg);
		}
	};

	inline _Dependency_Vec _build_dependency_vector(package& main_project) {
		_Dependency_Vec dep;
		_add_packages(dep, main_project);

		// Iterate through the packages and find/remove duplicates
		std::erase_if(dep, [&](const package* pkg) {
			for (const auto* p : dep) {
				if (p != pkg && p->name == pkg->name) {
					return true;
				}
			}
			return false;
		});

		return dep;
	}

	bool _verify_bin_and_build_directories(const std::string& project_name) {
		const auto& bin_dir = options().bin_dir;
		const auto& build_dir = options().build_dir / project_name;
		// Create the desired bin directory if it doesn't exist already.
		if (!fs::exists(bin_dir)) {
			try {
				fs::create_directories(bin_dir);
			} catch (std::exception& e) {
				_STD_BUILD_OUTPUT("Failed to create directory " << bin_dir.string() << '\n');
				_STD_BUILD_FAILURE_RETURN();
			}
		}

		// Create the desired build directory if it doesn't exist already.
		if (!fs::exists(build_dir)) {
			try {
				fs::create_directories(build_dir);
			} catch (std::exception& e) {
				_STD_BUILD_OUTPUT("Failed to create directory " << build_dir.string() << '\n');
				_STD_BUILD_FAILURE_RETURN();
			}
		}

		return true;
	}

	bool compile(const fs::path& build_dir,
	             const fs::path& directory,
	             const string_list& flags,
	             const path_list& include_dirs,
	             const fs::path& cpp_file) {
		std::stringstream output;

		output << _STD_BUILD_COMPILER << " -c " << flags;

		for (const auto& i : include_dirs) {
			output << "-I" << i << ' ';
		}

		output << directory / cpp_file << " -o " << (build_dir / cpp_file.stem()).replace_extension(".o");
		if (command(output.str())) {
			_STD_BUILD_OUTPUT("\nThere was an error during compilation:\n");
			_print_error_log();
			return false;
		}
		return true;
	}

	bool compile(const fs::path& build_dir,
	             const fs::path& directory,
	             const string_list& flags,
	             const path_list& include_dirs,
	             const path_list& cpp_files) {
		if (cpp_files.size() > 0) {
			_STD_BUILD_VERBOSE_OUTPUT("Compiling...\n");

			for (const auto& file : cpp_files) {
				if (compile(build_dir, directory, flags, include_dirs, file.value) == false) {
					return false;
				}
			}
		}
		return true;
	}

	// bool link(const std::string& binary_name, const fs::path& build_dir, const path_list& obj_files, const path_list&
	// library_dirs, const string_list& libraries) { 	_STD_BUILD_VERBOSE_OUTPUT("Linking..."); 	const std::string
	// binary_path = (options().bin_dir / binary_name).string(); 	std::stringstream output; 	output <<
	// _STD_BUILD_COMPILER
	// << ' ' << obj_files.value() << " -o " << binary_path << ' ' << lids.str()
	// 		<< ls.str();
	// 	_STD_BUILD_VERBOSE_OUTPUT('\n');
	// 	if (command(output.str())) {
	// 		_STD_BUILD_OUTPUT("\nThere was an error during linking:\n");
	// 		_print_error_log();
	// 		_STD_BUILD_FAILURE_RETURN();
	// 	} else {
	// 		_STD_BUILD_VERBOSE_OUTPUT("output");
	// 		_STD_BUILD_OUTPUT(" - " << binary_path << '\n');
	// 	}
	// }

	////////////// Create Binaries //////////////

	inline std::optional<_Library_Output> create_library(package& pkg) {
		_STD_BUILD_OUTPUT(
		    pkg.name << " - "
		             << (pkg.type == header_library ? "header\n" : (pkg.type == static_library ? "static" : "shared")));

		if (pkg.type != header_library) {
			_STD_BUILD_VERBOSE_OUTPUT('\n');
		}

		if (!_verify_bin_and_build_directories(pkg.name)) {
			return std::nullopt;
		};
		auto bin_dir = options().bin_dir;
		const auto build_dir = options().build_dir;
		const auto project_build_dir = build_dir / pkg.name;


		// Transform library include directories by adding the project directory to the beginning.
		for (auto& id : pkg.include_dirs) {
			id = { (pkg.dir / id.value).string(), id.access_level };
		}

		if (pkg.type != header_library) {
			if (pkg.sources.size() > 0) {
				// auto objs = compile(pkg);
				auto comp = compile(project_build_dir, pkg.dir, pkg.flags, pkg.include_dirs, pkg.sources);
				if (!comp) {
					return std::nullopt;
				}

				// if (!objs) {
				// 	return std::nullopt;
				// }

				// Convert all source file names into corresponding object file names.
				std::stringstream obj_files;
				for (const auto& source : pkg.sources) {
					obj_files << (project_build_dir / (source.value.stem().replace_extension(".o"))).string() << ' ';
				}

				auto file = fs::path("lib" + pkg.name);
				_STD_BUILD_VERBOSE_OUTPUT("Linking...");
				std::stringstream output;

				if (pkg.type == static_library) {
					file.replace_extension(".a");
					output << "ar rcs " << bin_dir / file << ' ' << obj_files.str();
				} else if (pkg.type == shared_library) {
					file.replace_extension(".so");
					output << _STD_BUILD_COMPILER << " -shared -o " << bin_dir / file << ' ' << obj_files.str();
				}

				_STD_BUILD_VERBOSE_OUTPUT('\n');
				if (command(output.str())) {
					std::cout << "\nThere was an error in creating the library:\n";
					_print_error_log();
					return std::nullopt;
				}
				_STD_BUILD_VERBOSE_OUTPUT("output");
				_STD_BUILD_OUTPUT(" - " << (bin_dir / file).string() << '\n');
				return _Library_Output(bin_dir, pkg.name, pkg.type);
			} else {
				_STD_BUILD_VERBOSE_OUTPUT("No sources given, assuming header only.\n");
			}
		}
		return _Library_Output(bin_dir, pkg.name, header_library);
	}

	inline bool create_executable(package& project) {
		// Verify that we have source files to work with.
		if (project.sources.size() == 0) {
			_STD_BUILD_OUTPUT("No source files.\n");
			_STD_BUILD_FAILURE_RETURN();
		}

		for (const auto& source : project.sources) {
			if (fs::exists(source.value) == false) {
				_STD_BUILD_OUTPUT("Source file: " << source.value.string() << " could not be found.\n");
				_STD_BUILD_FAILURE_RETURN();
			}
		}

		if (!_verify_bin_and_build_directories(project.name)) {
			return false;
		};
		const auto bin_dir = options().bin_dir;
		const auto build_dir = options().build_dir;
		const auto project_build_dir = build_dir / project.name;

		// Transform include & library directories by prepending the project's working directory
		for (auto& id : project.include_dirs) {
			id = (project.dir / id.value);
		}

		for (auto& ld : project.library_dirs) {
			ld = (project.dir / ld.value);
		}

		// Load Cache
		_STD_BUILD_OUTPUT("Loading cache: ");
		const auto cache_path = build_dir / project.name / "cache";
		__cache::cache_storage cache;
		path_list files_to_compile;

		const auto [initialized, new_cache] =
		    __cache::initialize_cache(cache_path, project.include_dirs, project.sources);
		if (initialized) {
			files_to_compile = project.sources;
			cache = new_cache;
		} else {
			if (!cache.load_from_file(cache_path)) {
				files_to_compile = project.sources;
				_STD_BUILD_OUTPUT("failed to load file.\n");
			} else {
				cache.test(project.sources);
				files_to_compile += cache.changes.added;
				files_to_compile += cache.changes.modified;
				_STD_BUILD_OUTPUT("complete [" << files_to_compile.size() + cache.changes.removed.size()
				                               << " changes]\n");
			}
		}

		// Add all dependency pointers to a vector and remove duplicates with the same name.
		auto dep = _build_dependency_vector(project);

		// Create the libraries and add them to a vector for future iteration
		std::vector<_Library_Output> libraries;
		if (dep.size() > 0) {
			_STD_BUILD_VERBOSE_OUTPUT("Building Dependencies: ");
			for (const auto* p : dep) {
				_STD_BUILD_VERBOSE_OUTPUT(p->name << ' ');
			}
			_STD_BUILD_VERBOSE_OUTPUT('\n');
			for (package* d : dep) {
				if (auto lib = create_library(*d)) {
					libraries.push_back(lib.value());
				} else {
					_STD_BUILD_FAILURE_RETURN();
				}

				// Add this dependencies include/lib directories to our main project's include/lib directories
				for (const auto& inc_dir : d->include_dirs) {
					if (inc_dir.access_level == access::all) {
						project.include_dirs.add(inc_dir);
					}
				}

				for (const auto& lib_dir : d->library_dirs) {
					if (lib_dir.access_level == access::all) {
						project.library_dirs.add(lib_dir);
					}
				}
			}
		}

		_STD_BUILD_OUTPUT(project.name << " - executable");
		_STD_BUILD_VERBOSE_OUTPUT('\n');

		// Add debug flag
		if (debugging_enabled()) {
			project.flags += "-g";
		}

		auto comp = compile(project_build_dir, project.dir, project.flags, project.include_dirs, files_to_compile);
		if (!comp) {
			_STD_BUILD_FAILURE_RETURN();
		}

		std::stringstream lds; // Library Directory String
		std::stringstream ls;  // Libraries String
		for (const auto& lib : libraries) {
			if (lib.type != header_library) {
				lds << "-L" << lib.location.string() << ' ';
				ls << "-l" << lib.name.string() << ' ';
			}
		}

		for (const auto& lib_dir : project.library_dirs) {
			ls << "-L" << lib_dir.value << ' ';
		}

		for (const auto& lib : project.libraries) {
			ls << "-l" << lib.value << ' ';
		}

		// Convert all source file names into corresponding object file names.
		std::stringstream obj_files;
		for (const auto& source : project.sources) {
			obj_files << (project_build_dir / (source.value.stem().replace_extension(".o"))).string() << ' ';
		}

		_STD_BUILD_VERBOSE_OUTPUT("Linking...");
		std::stringstream output;
		output << _STD_BUILD_COMPILER << ' ' << obj_files.str() << " -o " << (bin_dir / project.name) << ' '
		       << lds.str() << ls.str();
		_STD_BUILD_VERBOSE_OUTPUT('\n');
		if (command(output.str())) {
			_STD_BUILD_OUTPUT("\nThere was an error during linking:\n");
			_print_error_log();
			_STD_BUILD_FAILURE_RETURN();
		} else {
			_STD_BUILD_VERBOSE_OUTPUT("output");
			_STD_BUILD_OUTPUT(" - " << (bin_dir / project.name).string() << '\n');
		}

		// Update cache
		// std::cout << "Before updating: \n\n" << cache << "\n\n";
		cache.update(project.include_dirs);
		// std::cout << "After updating: \n\n" << cache << "\n\n";
		cache.write_to_file(cache_path);

#ifdef _STD_BUILD_RUN
		_STD_BUILD_OUTPUT("Running...\n\n");
		auto exe = (bin_dir / project.name).replace_extension(".exe").make_preferred();
		if (fs::exists(exe)) {
			command(exe.string());
		} else {
			_STD_BUILD_OUTPUT("Failed to find executable.\n");
		}
#endif
		return true;
	}

} // namespace _STD_BUILD