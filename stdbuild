#pragma once

#include <concepts>
#include <filesystem>
#include <iostream>
#include <map>
#include <sstream>
#include <string>
#include <vector>
#include <optional>
#include <fstream>

#if defined(__cpp_lib_constexpr_vector) && defined(__cpp_lib_constexpr_string)
#define _CONSTEXPR_20 constexpr
#else
#define _CONSTEXPR_20
#endif

#if (__cplusplus >= 201703L)
#define _CONSTEXPR_17 constexpr
#else
#define _CONSTEXPR_17
#endif

#define _STD_BUILD std::build
#define _STD_BUILD_OUTPUT(str) std::cout << str;

#ifdef _STD_BUILD_VERBOSE
#define _STD_BUILD_VERBOSE_OUTPUT(str) std::cout << str
#else
#define _STD_BUILD_VERBOSE_OUTPUT(str)
#endif

#if defined(_MSC_VER)
#define _STD_BUILD_COMPILER "cl"
#elif defined(__GNUC__)
#define _STD_BUILD_COMPILER "g++"
#elif defined(__clang__)
#define _STD_BUILD_COMPILER "clang"
#else
#error A supported compiler (msvc, g++, clang) must be used.
#endif

namespace _STD_BUILD {

	enum class build_type : unsigned int { static_library, shared_library, header_library };

	using build_path = std::filesystem::path;

	template <typename Type>
	class list_base;

	template <typename From, typename... To>
	concept _Is_Convertable_Multi = (std::convertible_to<From, To> || ...);

	template <typename T1, typename... FlagType>
	concept _List_Test = (_Is_Convertable_Multi<FlagType, T1, list_base<T1>> && ...);

	////////////// Options //////////////

	struct _Options {
		std::filesystem::path build_dir{ "build/" };
		std::filesystem::path bin_dir{ "bin/" };
		std::string output_redirect_str{ " 2>build/error" }; //">build/output 2>build/error" };
		// std::string output_file{ "build/output" };
		std::string error_file{ "build/error" };
		bool debug{ false };

		void set(const std::string& opt, bool value) { _user_defined_opts[opt] = value; }
		bool get(const std::string& opt) { return _user_defined_opts[opt]; }

	private:
		std::map<std::string, bool> _user_defined_opts;
	};

	inline _Options& options() {
		static _Options opt;
		return opt;
	}

	inline void set_build_directory(std::filesystem::path path) {
		if (!std::filesystem::exists(path)) {
			std::filesystem::create_directory(path);
		}

		options().build_dir = path;
		// options().output_file = (path / "output").string();
		options().error_file = (path / "error").string();
		options().output_redirect_str = " 2>" + options().error_file;
		//">" + options().output_file + " 2>" + options().error_file;
	}

	inline void set_bin_directory(std::filesystem::path path) {
		if (!std::filesystem::exists(path)) {
			std::filesystem::create_directory(path);
		}

		options().bin_dir = path;
	}

	inline void set_option(const std::string& opt, bool value) { options().set(opt, value); }

	inline bool get_option(const std::string& opt) { return options().get(opt); }

	inline void enable_debugging() { options().debug = true; }

	inline void disable_debugging() { options().debug = false; }

	inline bool debugging_enabled() { return options().debug; }

	////////////// Error Handling //////////////

	void _print_error_log() {
		std::ifstream error(options().error_file);
		if (error) {
			std::cout << error.rdbuf();
			error.close();
		}
	}

	////////////// Command //////////////

	int command(const std::string& cmd) {
		_STD_BUILD_VERBOSE_OUTPUT("Running command: " << cmd << '\n');
		return std::system((cmd + options().output_redirect_str).c_str());
	}

	////////////// version //////////////

	struct version {
		_CONSTEXPR_17 version() = default;
		_CONSTEXPR_17 version(uint32_t major, uint32_t minor, uint32_t patch)
		    : m_major(major), m_minor(minor), m_patch(patch) {}
		_CONSTEXPR_17 const uint32_t major() const { return m_major; }
		_CONSTEXPR_17 const uint32_t minor() const { return m_minor; }
		_CONSTEXPR_17 const uint32_t patch() const { return m_patch; }
		_CONSTEXPR_17 bool operator>(const version& other) const {
			return (m_major > other.m_major || m_minor > other.m_minor || m_patch > other.m_patch);
		}

		_CONSTEXPR_17 bool operator<(const version& other) const {
			return (m_major < other.m_major || m_minor < other.m_minor || m_patch < other.m_patch);
		}

		_CONSTEXPR_17 bool operator==(const version& other) const {
			return (m_major == other.m_major && m_minor == other.m_minor && m_patch == other.m_patch);
		}

		_CONSTEXPR_17 bool operator>=(const version& other) const {
			return (m_major >= other.m_major && m_minor >= other.m_minor && m_patch >= other.m_patch);
		}

		_CONSTEXPR_17 bool operator<=(const version& other) const {
			return (m_major <= other.m_major && m_minor <= other.m_minor && m_patch <= other.m_patch);
		}

	private:
		uint32_t m_major{ 0 }, m_minor{ 0 }, m_patch{ 0 };
	};

	////////////// List //////////////

	// all = public, parent = interface, self = private
	enum class access : uint8_t { all, parent, self };

	template <typename Type>
	struct _Exporter {
		_Exporter() = default;

		template <typename _Type>
		requires std::is_convertible_v<_Type, Type> _Exporter(const _Type& value) : m_value(value) {}

		template <typename _Type>
		requires std::is_convertible_v<_Type, Type> _Exporter(const _Type& value, access access_level)
		    : m_value(value), m_access_level(access_level) {}

		Type& value() { return m_value; }
		const Type& value() const { return m_value; }
		access access_level() const { return m_access_level; }

	private:
		Type m_value;
		access m_access_level{ access::all };
	};

	template <typename Type>
	std::ostream& operator<<(std::ostream& os, const _Exporter<Type>& e) {
		os << e.value();
		return os;
	}

	template <typename Type>
	class list_base {
	private:
		template <typename _Type, typename Stream, typename = void>
		struct is_streamable : std::false_type {};

		template <typename _Type, typename Stream>
		struct is_streamable<_Type, Stream, std::void_t<decltype(std::declval<Stream&>() << std::declval<_Type>())>>
		    : std::true_type {};

	public:
		_CONSTEXPR_20 list_base() = default;
		_CONSTEXPR_20 list_base(const list_base<Type>& list) : m_items(list.m_items) {}
		_CONSTEXPR_20 list_base(std::initializer_list<Type> strings) {
			m_items.insert(m_items.end(), strings.begin(), strings.end());
		}

		/// Misc Functions ///

		_CONSTEXPR_20 std::vector<Type>& get() { return m_items; }
		_CONSTEXPR_20 const std::vector<Type>& get() const { return m_items; }
		_CONSTEXPR_20 std::size_t size() const { return m_items.size(); }
		_CONSTEXPR_20 void add(const Type& item) { m_items.push_back(item); }

		// TODO: improve this
		template <typename _Type = Type>
		_CONSTEXPR_20 auto string(unsigned char delim = ' ') const
		    -> std::enable_if_t<is_streamable<Type, std::ostream>::value, _Type> {
			if (m_items.size() > 0) {
				std::ostringstream ss;
				for (const auto& item : m_items) {
					ss << item << delim;
				}
				auto str = std::move(ss.str());
				str.erase(str.end() - 1); // Removes the last delimiter from the string
				return str;
			}
			return "";
		}

		/// Operators ///

		_CONSTEXPR_20 list_base<Type>& operator=(const list_base<Type>& list) {
			if (this != &list) {
				m_items = list.m_items;
			}
			return *this;
		}

		_CONSTEXPR_20 list_base<Type>& operator=(list_base<Type>&& list) {
			if (this != &list) {
				m_items = std::move(list.m_items);
			}
			return *this;
		}

		_CONSTEXPR_20 void operator+=(const Type& item) { add(item); }

		_CONSTEXPR_20 void operator+=(const list_base<Type>& list) {
			m_items.insert(m_items.end(), list.m_items.begin(), list.m_items.end());
		}

		/// Iterator Functions ///

		_CONSTEXPR_20 auto begin() { return m_items.begin(); }
		_CONSTEXPR_20 const auto begin() const { return m_items.begin(); }
		_CONSTEXPR_20 auto end() { return m_items.end(); }
		_CONSTEXPR_20 const auto end() const { return m_items.end(); }

	private:
		_CONSTEXPR_20 std::vector<Type> m_items;
	};

	template <typename Type>
	std::ostream& operator<<(std::ostream& os, const list_base<Type>& list) {
		for (const auto& item : list.get()) {
			os << item << ' ';
		}
		return os;
	}

	using string_list = list_base<_Exporter<std::string>>;

	////////////// Package //////////////

	struct package;
	using package_list = list_base<package>;

	struct package {
		package() = default;
		explicit package(const std::string& _name) : name(_name) {}
		string_list include_dirs, library_dirs, flags, sources, libraries;
		package_list pkgs;
		version ver{ 0, 0, 0 };
		std::string name{ "package" };
		build_path dir{ "." };
		build_type type{ build_type::static_library };
	};

	////////////// Library //////////////

	struct _Library_Output {
		std::filesystem::path location;
		std::filesystem::path name;
		build_type type{ build_type::static_library };
		_Library_Output(std::filesystem::path _location, std::filesystem::path _name, build_type _type)
		    : location(_location), name(_name), type(_type) {}
	};

	////////////// Compilation //////////////

	using _Dependency_Vec = std::vector<package*>;

	inline void _add_packages(_Dependency_Vec& dep, package& project) {
		for (auto& pkg : project.pkgs) {
			dep.push_back(&pkg);
			_add_packages(dep, pkg);
		}
	};

	inline _Dependency_Vec _build_dependency_vector(package& main_project) {
		_Dependency_Vec dep;
		_add_packages(dep, main_project);

		// Iterate through the packages and find/remove duplicates
		std::erase_if(dep, [&](const package* pkg) {
			for (const auto* p : dep) {
				if (p != pkg && p->name == pkg->name) {
					return true;
				}
			}
			return false;
		});

		return dep;
	}

	inline std::optional<string_list> compile(const package& project) {
		_STD_BUILD_VERBOSE_OUTPUT("Compiling...\n");
		auto build_dir = options().build_dir / project.name;

		// Create the desired build directory if it doesn't exist already.
		if (!std::filesystem::exists(build_dir)) {
			try {
				std::filesystem::create_directories(build_dir);
			} catch (std::exception& e) {
				_STD_BUILD_OUTPUT("Failed to create directory " << build_dir.string() << '\n');
				return std::nullopt;
			}
		}

		string_list obj_files;

		for (const auto& f : project.sources) {
			std::stringstream output;
			std::filesystem::path fp(f.value());
			auto obj_path = (build_dir / fp.stem()).replace_extension(".o");

			output << _STD_BUILD_COMPILER << " -c " << project.flags;

			for (const auto& i : project.include_dirs) {
				output << "-I" << i << ' ';
			}

			output << project.dir / fp << " -o " << obj_path;
			obj_files += std::move(obj_path.string());
			int ret = command(output.str());
			if (ret) {
				_STD_BUILD_OUTPUT("\nThere was an error during compilation:\n");
				_print_error_log();
				return std::nullopt;
			}
		}

		return obj_files;
	}

	////////////// Create Binaries //////////////

	inline std::optional<_Library_Output> create_library(package& pkg) {
		_STD_BUILD_OUTPUT(pkg.name << " - "
		                           << (pkg.type == build_type::header_library ?
		                                   "header\n" :
		                                   (pkg.type == build_type::static_library ? "static" : "shared")));

		if (pkg.type != build_type::header_library) {
			_STD_BUILD_VERBOSE_OUTPUT('\n');
		}

		auto bin_dir = options().bin_dir;

		// Create the desired bin directory if it doesn't exist already.
		if (!std::filesystem::exists(bin_dir)) {
			std::filesystem::create_directory(bin_dir);
		}

		// Transform library include directories by adding the project directory to the beginning.
		for (auto& id : pkg.include_dirs) {
			id = { (pkg.dir / id.value()).string(), id.access_level() };
		}

		if (pkg.type != build_type::header_library) {
			if (pkg.sources.size() > 0) {
				auto objs = compile(pkg);

				if (!objs) {
					return std::nullopt;
				}

				if (objs.value().size() > 0) {
					auto file = std::filesystem::path("lib" + pkg.name);
					_STD_BUILD_VERBOSE_OUTPUT("Linking...");
					std::stringstream output;

					if (pkg.type == build_type::static_library) {
						file.replace_extension(".a");
						output << "ar rcs " << bin_dir / file << ' ' << objs.value();
					} else if (pkg.type == build_type::shared_library) {
						file.replace_extension(".so");
						output << _STD_BUILD_COMPILER << " -shared -o " << bin_dir / file << ' ' << objs.value();
					}

					_STD_BUILD_VERBOSE_OUTPUT('\n');
					int ret = command(output.str());
					if (ret) {
						std::cout << "\nThere was an error in creating the library:\n";
						_print_error_log();
						return std::nullopt;
					}
					_STD_BUILD_VERBOSE_OUTPUT("output");
					_STD_BUILD_OUTPUT(" - " << (bin_dir / file).string() << '\n');
					return _Library_Output(bin_dir, pkg.name, pkg.type);
				}
			} else {
				_STD_BUILD_VERBOSE_OUTPUT("No sources given, assuming header only.\n");
			}
		}
		return _Library_Output(bin_dir, pkg.name, build_type::header_library);
	}

	inline bool create_executable(package& project) {
		// Verify that we have source files to work with.
		if (project.sources.size() == 0) {
			_STD_BUILD_OUTPUT("No source files.\n");
			return false;
		}

		// Get the desired bin location
		auto bin_dir = options().bin_dir;

		// Create the desired bin directory if it doesn't exist already.
		if (!std::filesystem::exists(bin_dir)) {
			std::filesystem::create_directory(bin_dir);
		}

		// Transform include & library directories by prepending the project's working directory
		for (auto& id : project.include_dirs) {
			id = (project.dir / id.value()).string();
		}

		for (auto& ld : project.library_dirs) {
			ld = (project.dir / ld.value()).string();
		}

		// Add all dependency pointers to a vector and remove duplicates with the same name.
		auto dep = _build_dependency_vector(project);

		// Create the libraries and add them to a vector for future iteration
		std::vector<_Library_Output> libraries;
		if (dep.size() > 0) {
			_STD_BUILD_VERBOSE_OUTPUT("Building Dependencies: ");
			for (const auto* p : dep) {
				_STD_BUILD_VERBOSE_OUTPUT(p->name << ' ');
			}
			_STD_BUILD_VERBOSE_OUTPUT('\n');
			for (package* d : dep) {
				if (auto lib = create_library(*d)) {
					libraries.push_back(lib.value());
				} else {
					return false;
				}

				// Add this dependencies include/lib directories to our main project's include/lib directories
				for (const auto& inc_dir : d->include_dirs) {
					if (inc_dir.access_level() == access::all) {
						project.include_dirs += inc_dir;
					}
				}

				for (const auto& lib_dir : d->library_dirs) {
					if (lib_dir.access_level() == access::all) {
						project.library_dirs += lib_dir;
					}
				}
			}
		}

		_STD_BUILD_OUTPUT(project.name << " - executable");
		_STD_BUILD_VERBOSE_OUTPUT('\n');

		std::stringstream lids; // Library Include Directory String
		std::stringstream ls;   // Libraries String
		for (const auto& lib : libraries) {
			if (lib.type != build_type::header_library) {
				lids << "-L" << lib.location.string() << ' ';
				ls << "-l" << lib.name.string() << ' ';
			}
		}

		for (const auto& lib_dir : project.library_dirs) {
			ls << "-L" << lib_dir.value() << ' ';
		}

		for (const auto& lib : project.libraries) {
			ls << "-l" << lib.value() << ' ';
		}

		// Add debug flag
		if (debugging_enabled()) {
			project.flags += "-g";
		}

		auto objs = compile(project);

		if (!objs) {
			return false;
		}

		_STD_BUILD_VERBOSE_OUTPUT("Linking...");
		std::stringstream output;
		output << _STD_BUILD_COMPILER << ' ' << objs.value() << " -o " << (bin_dir / project.name) << ' ' << lids.str()
		       << ls.str();
		_STD_BUILD_VERBOSE_OUTPUT('\n');
		int ret = command(output.str());
		if (ret) {
			_STD_BUILD_OUTPUT("\nThere was an error during linking:\n");
			_print_error_log();
			return false;
		} else {
			_STD_BUILD_VERBOSE_OUTPUT("output");
			_STD_BUILD_OUTPUT(" - " << (bin_dir / project.name).string() << '\n');
#ifdef _STD_BUILD_RUN
			_STD_BUILD_OUTPUT("Running...\n\n");
			auto exe = (bin_dir / project.name).replace_extension(".exe").make_preferred();
			if (std::filesystem::exists(exe)) {
				command(exe.string());
			} else {
				_STD_BUILD_OUTPUT("Failed to find executable.\n");
			}
#endif
			return true;
		}
	}

} // namespace _STD_BUILD