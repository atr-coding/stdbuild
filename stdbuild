#pragma once

#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <filesystem>
#include <concepts>

#if defined(__cpp_lib_constexpr_vector) && defined(__cpp_lib_constexpr_string)
#define _CONSTEXPR_20 constexpr
#else
#define _CONSTEXPR_20
#endif

#if (__cplusplus >= 201703L)
#define _CONSTEXPR_17 constexpr
#else
#define _CONSTEXPR_17
#endif

#define _STD_BUILD std::build
#define _STD_BUILD_OUTPUT(str) std::cout << str;

#ifdef _STD_BUILD_VERBOSE
#define _STD_BUILD_VERBOSE_OUTPUT(str) std::cout << str
#else
#define _STD_BUILD_VERBOSE_OUTPUT(str)
#endif

#if defined(_MSC_VER)
#define _STD_BUILD_COMPILER "cl"
#elif defined(__GNUC__)
#define _STD_BUILD_COMPILER "g++"
#elif defined(__clang__)
#define _STD_BUILD_COMPILER "clang"
#else
#error A supported compiler (cl, g++, clang) must be used.
#endif

namespace _STD_BUILD {

	enum class build_type : unsigned int { static_library, shared_library, header_library };

	using build_path = std::filesystem::path;

	template<typename Type>
	class ListBase;

	template<typename From, typename... To>
	concept _Is_Convertable_Multi = (std::convertible_to<From, To> || ...);

	template<typename T1, typename... FlagType>
	concept _List_Test = (_Is_Convertable_Multi<FlagType, T1, ListBase<T1>> && ...);

	////////////// Options //////////////

	struct _Options {
		std::filesystem::path build_dir{ "build/" };
		std::filesystem::path bin_dir{ "bin/" };
	};

	inline _Options& options() {
		static _Options opt;
		return opt;
	}

	inline void set_build_directory(std::filesystem::path path) {
		if (!std::filesystem::exists(path)) {
			std::filesystem::create_directory(path);
		}

		options().build_dir = path;
	}

	inline void set_bin_directory(std::filesystem::path path) {
		if (!std::filesystem::exists(path)) {
			std::filesystem::create_directory(path);
		}

		options().bin_dir = path;
	}

	////////////// Command //////////////

	void command(const std::string& cmd) {
		_STD_BUILD_VERBOSE_OUTPUT("Running command: " << cmd << '\n');
		std::system(cmd.c_str());
	}

	////////////// Version //////////////

	struct Version {
		_CONSTEXPR_17 Version() = default;
		_CONSTEXPR_17 Version(uint32_t major, uint32_t minor, uint32_t patch) : m_major(major), m_minor(minor), m_patch(patch) {}
		_CONSTEXPR_17 uint32_t major() { return m_major; }
		_CONSTEXPR_17 const uint32_t major() const { return m_major; }
		_CONSTEXPR_17 uint32_t minor() { return m_minor; }
		_CONSTEXPR_17 const uint32_t minor() const { return m_minor; }
		_CONSTEXPR_17 uint32_t patch() { return m_patch; }
		_CONSTEXPR_17 const uint32_t patch() const { return m_patch; }
		_CONSTEXPR_17 bool operator>(const Version& other) { return (m_major > other.m_major || m_minor > other.m_minor || m_patch > other.m_patch); }
		_CONSTEXPR_17 bool operator<(const Version& other) { return (m_major < other.m_major || m_minor < other.m_minor || m_patch < other.m_patch); }
		_CONSTEXPR_17 bool operator==(const Version& other) { return (m_major == other.m_major && m_minor == other.m_minor && m_patch == other.m_patch); }
		_CONSTEXPR_17 bool operator>=(const Version& other) { return (m_major >= other.m_major && m_minor >= other.m_minor && m_patch >= other.m_patch); }
		_CONSTEXPR_17 bool operator<=(const Version& other) { return (m_major <= other.m_major && m_minor <= other.m_minor && m_patch <= other.m_patch); }
	private:
		uint32_t m_major{ 0 }, m_minor{ 0 }, m_patch{ 0 };
	};

	////////////// List //////////////

	template<typename Type>
	class ListBase {
	public:
		_CONSTEXPR_20 ListBase() = default;
		_CONSTEXPR_20 ListBase(const ListBase<Type>& other) : m_flags(other.m_flags) {}
		_CONSTEXPR_20 ListBase(ListBase<Type>&& other) : m_flags(std::move(other.m_flags)) {}

		template<typename... FlagType> requires _List_Test<Type, FlagType...>
		_CONSTEXPR_20 ListBase(const Type& flag, const FlagType&... flags) {
			add_flags(flag);
			(add_flags(flags), ...);
		}

		template<typename... FlagType> requires _List_Test<Type, FlagType...>
		_CONSTEXPR_20 ListBase(const ListBase<Type>& flag, const FlagType&... flags) {
			add_flags(flag);
			(add_flags(flags), ...);
		}

		/// ListBase Operators ///

		_CONSTEXPR_20 ListBase<Type>& operator=(const ListBase<Type>& other) {
			if (this != &other) {
				m_flags = other.m_flags;
			}
			return *this;
		}

		_CONSTEXPR_20 ListBase<Type>& operator=(ListBase<Type>&& other) {
			if (this != &other) {
				m_flags = std::move(other.m_flags);
			}
			return *this;
		}

		_CONSTEXPR_20 ListBase<Type> operator+(const ListBase<Type>& other) {
			ListBase<Type> new_list(*this);
			new_list += other;
			return new_list;
		}

		_CONSTEXPR_20 ListBase<Type> operator+(const Type& flag) {
			ListBase<Type> new_list(*this);
			new_list += flag;
			return new_list;
		}

		_CONSTEXPR_20 void operator+=(const ListBase<Type>& other) { m_flags.insert(m_flags.end(), other.m_flags.begin(), other.m_flags.end()); }
		_CONSTEXPR_20 void operator+=(const Type& flag) { m_flags.push_back(flag); }
		_CONSTEXPR_20 void operator+=(Type&& flag) { m_flags.push_back(std::move(flag)); }

		/// End ListBase Operators ///

		_CONSTEXPR_20 std::vector<Type>& get() { return m_flags; }
		_CONSTEXPR_20 const std::vector<Type>& get() const { return m_flags; }
		_CONSTEXPR_20 auto begin() { return m_flags.begin(); }
		_CONSTEXPR_20 const auto begin() const { return m_flags.begin(); }
		_CONSTEXPR_20 auto end() { return m_flags.end(); }
		_CONSTEXPR_20 const auto end() const { return m_flags.end(); }
		_CONSTEXPR_20 std::size_t size() { return m_flags.size(); }
		_CONSTEXPR_20 const std::size_t size() const { return m_flags.size(); }
	private:
		_CONSTEXPR_20 void add_flags(const Type& flag) { m_flags.push_back(flag); }
		_CONSTEXPR_20 void add_flags(const ListBase<Type>& other) { m_flags.insert(m_flags.end(), other.begin(), other.end()); }
	private:
		_CONSTEXPR_20 std::vector<Type> m_flags;
	};

	using List = ListBase<std::string>;
	using DirectoryList = ListBase<build_path>;

	template<typename T>
	_CONSTEXPR_20 ListBase<T> operator+(const std::string& flag, const ListBase<T>& other) {
		List new_list(flag);
		new_list += other;
		return new_list;
	}

	template<typename T>
	std::ostream& operator<<(std::ostream& os, const ListBase<T>& list) {
		for (const auto& i : list.get()) {
			os << i << ' ';
		}
		return os;
	}

	////////////// Library //////////////

	struct Package;
	using Packages = ListBase<Package>;

	struct Package {
		List include_dirs, library_dirs, flags, sources, libraries;
		Packages packages;
		Version version{ 0, 0, 0 };
		std::string name;
		build_path dir{ "." };
		build_type type{ build_type::static_library };
	};

	////////////// Library //////////////

	struct Library {
		std::filesystem::path location;
		std::filesystem::path name;
		build_type type{ build_type::static_library };
		Library(std::filesystem::path _location, std::filesystem::path _name, build_type _type) : location(_location), name(_name), type(_type) {}
	};

	////////////// Compilation //////////////

	using _Dependency_Vec = std::vector<Package*>;
	using _Dependency_Vec_Ref = _Dependency_Vec&;

	inline void _add_packages(_Dependency_Vec_Ref dep, Package& project) {
		for (auto& package : project.packages) {
			dep.push_back(&package);
			_add_packages(dep, package);
		}
	};

	inline _Dependency_Vec _build_dependency_vector(Package& main_project) {
		_Dependency_Vec dep;
		_add_packages(dep, main_project);

		// Iterate through the packages and find/remove duplicates
		std::erase_if(dep, [&](const Package* pkg) {
			for (const auto* p : dep) {
				if (p != pkg && p->name == pkg->name) { return true; }
			}
			return false;
			});

		return std::move(dep);
	}

	inline List compile(const Package& project) {
		_STD_BUILD_VERBOSE_OUTPUT("Compiling...\n");
		auto build_dir = options().build_dir / project.name;

		// Create the desired build directory if it doesn't exist already.
		if (!std::filesystem::exists(build_dir)) { std::filesystem::create_directory(build_dir); }

		List obj_files;

		for (const auto& f : project.sources) {
			std::stringstream output;
			std::filesystem::path fp(f);
			auto obj_path = (build_dir / fp.stem()).replace_extension(".o");

			output << _STD_BUILD_COMPILER << " -c " << project.flags;
			for (const auto& i : project.include_dirs) { output << "-I" << i << ' '; }
			output << project.dir / fp << " -o " << obj_path;
			obj_files += std::move(obj_path.string());
			command(output.str());
		}

		return obj_files;
	}

	////////////// Create Binaries //////////////

	inline Library create_library(Package& package) {
		_STD_BUILD_OUTPUT("---------- Library: " << package.name << " ----------\n");
		auto bin_dir = options().bin_dir;

		// Create the desired bin directory if it doesn't exist already.
		if (!std::filesystem::exists(bin_dir)) { std::filesystem::create_directory(bin_dir); }

		// Transform library include directories by adding the project directory to the beginning.
		for (auto& id : package.include_dirs) { id = (package.dir / id).string(); }

		if (package.type != build_type::header_library) {
			if (package.sources.size() > 0) {
				auto objs = compile(package);

				if (objs.size() > 0) {
					auto file = std::filesystem::path("lib" + package.name);
					_STD_BUILD_VERBOSE_OUTPUT("Linking...");
					std::stringstream output;

					if (package.type == build_type::static_library) {
						file.replace_extension(".a");
						output << "ar rcs " << bin_dir / file << ' ' << objs;
					} else if (package.type == build_type::shared_library) {
						file.replace_extension(".so");
						output << _STD_BUILD_COMPILER << " -shared -o " << bin_dir / file << ' ' << objs;
					}

					_STD_BUILD_VERBOSE_OUTPUT('\n');
					command(output.str());
					_STD_BUILD_OUTPUT("Output: " << (bin_dir / file).string() << '\n');
					return Library(bin_dir, package.name, package.type);
				}
			} else {
				_STD_BUILD_VERBOSE_OUTPUT("No sources given, assuming header only.\n");
			}
		} else {
			_STD_BUILD_VERBOSE_OUTPUT("Header only.\n");
		}
		return Library(bin_dir, package.name, build_type::header_library);
	}

	inline void create_executable(Package& project) {
		// Verify that we have source files to work with.
		if (project.sources.size() == 0) { _STD_BUILD_OUTPUT("No source files.\n"); return; }

		// Get the desired bin location
		auto bin_dir = options().bin_dir;

		// Create the desired bin directory if it doesn't exist already.
		if (!std::filesystem::exists(bin_dir)) { std::filesystem::create_directory(bin_dir); }

		// Transform include & library directories by prepending the project's working directory
		for (auto& id : project.include_dirs) { id = (project.dir / id).string(); }
		for (auto& ld : project.library_dirs) { ld = (project.dir / ld).string(); }

		// Add all dependency pointers to a vector and remove duplicates with the same name.
		auto dep = _build_dependency_vector(project);

		// Create the libraries and add them to a vector for future iteration
		std::vector<Library> libraries;
		if (dep.size() > 0) {
			_STD_BUILD_OUTPUT("Building Dependencies: ");
			for (const auto* p : dep) { _STD_BUILD_OUTPUT(p->name << ' '); }
			_STD_BUILD_OUTPUT('\n');
			for (Package* d : dep) {
				libraries.push_back(create_library(*d));

				// Add this dependencies include directories to our main project's include directories
				for (const auto& inc_dir : d->include_dirs) {
					project.include_dirs += inc_dir;
				}
			}
		}

		_STD_BUILD_OUTPUT("---------- Executable: " << project.name << " ----------\n");

		std::stringstream lids; // Library Include Directory String
		std::stringstream ls; // Libraries String
		for (const auto& lib : libraries) {
			if (lib.type != build_type::header_library) {
				lids << "-L" << lib.location.string() << ' ';
				// ls << "-Wl, -B" << (lib.type == build_type::static_library ? "static -l" : "dynamic -l") << lib.name.string();
				ls << "-l" << lib.name.string() << ' ';
			}
		}

		auto objs = compile(project);

		_STD_BUILD_VERBOSE_OUTPUT("Linking...");
		std::stringstream output;
		output << _STD_BUILD_COMPILER << ' ' << objs << " -o " << (bin_dir / project.name) << ' ' << lids.str() << ls.str();
		_STD_BUILD_VERBOSE_OUTPUT('\n');
		command(output.str());
		_STD_BUILD_OUTPUT("Output: " << (bin_dir / project.name).string() << "\n");
	}
}