#pragma once

#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <filesystem>
#include <type_traits>
#include <concepts>
#include <cassert>

#if defined(__cpp_lib_constexpr_vector) && defined(__cpp_lib_constexpr_string)
// #define _CONSTEXPR_20 constexpr
#define _CONSTEXPR_20 constexpr
#else
#define _CONSTEXPR_20
#endif

#if (__cplusplus >= 201703L)
#define _CONSTEXPR_17 constexpr
#else
#define _CONSTEXPR_17
#endif

namespace std::build {

	enum class type : unsigned int { static_library, shared_library, executable };

	using build_path = std::filesystem::path;

	////////////// Options //////////////

	struct _Options {
		std::filesystem::path build_dir{ "build/" };
		std::filesystem::path bin_dir{ "bin/" };
		bool debug{ false };
		bool verbose{ false };
	};

	template<typename Type>
	class ListBase;

	template<typename From, typename... To>
	concept _Is_Convertable_Multi = (std::convertible_to<From, To> || ...);

	template<typename T1, typename... FlagType>
	concept _ListTest = (_Is_Convertable_Multi<FlagType, T1, ListBase<T1>> && ...);

	inline _Options& options() {
		static _Options opt;
		return opt;
	}

	inline void set_build_directory(std::filesystem::path path) {
		if (!std::filesystem::exists(path)) {
			std::filesystem::create_directory(path);
		}

		options().build_dir = path;
	}

	inline void set_bin_directory(std::filesystem::path path) {
		if (!std::filesystem::exists(path)) {
			std::filesystem::create_directory(path);
		}

		options().bin_dir = path;
	}

	inline void enable_debugging() {
		options().debug = true;
	}

	inline bool debug_enabled() {
		return options().debug;
	}

	inline void enable_verbose() {
		options().verbose = true;
	}

	inline void disable_verbose() {
		options().verbose = false;
	}

	////////////// Command //////////////

	void command(const std::string& cmd) {
		if (options().verbose) { std::cout << "Running command: " << cmd << '\n'; }
		std::system(cmd.c_str());
	}

	////////////// Version //////////////

	struct Version {
		_CONSTEXPR_17 Version() = default;
		_CONSTEXPR_17 Version(uint32_t major, uint32_t minor, uint32_t patch) : m_major(major), m_minor(minor), m_patch(patch) {}
		_CONSTEXPR_17 uint32_t major() { return m_major; }
		_CONSTEXPR_17 const uint32_t major() const { return m_major; }
		_CONSTEXPR_17 uint32_t minor() { return m_minor; }
		_CONSTEXPR_17 const uint32_t minor() const { return m_minor; }
		_CONSTEXPR_17 uint32_t patch() { return m_patch; }
		_CONSTEXPR_17 const uint32_t patch() const { return m_patch; }
		_CONSTEXPR_17 bool operator>(const Version& other) { return (m_major > other.m_major || m_minor > other.m_minor || m_patch > other.m_patch); }
		_CONSTEXPR_17 bool operator<(const Version& other) { return (m_major < other.m_major || m_minor < other.m_minor || m_patch < other.m_patch); }
		_CONSTEXPR_17 bool operator==(const Version& other) { return (m_major == other.m_major && m_minor == other.m_minor && m_patch == other.m_patch); }
		_CONSTEXPR_17 bool operator>=(const Version& other) { return (m_major >= other.m_major && m_minor >= other.m_minor && m_patch >= other.m_patch); }
		_CONSTEXPR_17 bool operator<=(const Version& other) { return (m_major <= other.m_major && m_minor <= other.m_minor && m_patch <= other.m_patch); }
	private:
		uint32_t m_major{ 0 }, m_minor{ 0 }, m_patch{ 0 };
	};

	////////////// List //////////////

	template<typename Type>
	class ListBase {
	public:
		_CONSTEXPR_20 ListBase() = default;
		_CONSTEXPR_20 ListBase(const ListBase<Type>& other) : m_flags(other.m_flags) {}
		_CONSTEXPR_20 ListBase(ListBase<Type>&& other) : m_flags(std::move(other.m_flags)) {}

		template<typename... FlagType> requires _ListTest<Type, FlagType...>
		_CONSTEXPR_20 ListBase(const Type& flag, const FlagType&... flags) {
			std::cout << "Type constructor\n";
			add_flags(flag);
			(add_flags(flags), ...);
		}

		template<typename... FlagType> requires _ListTest<Type, FlagType...>
		_CONSTEXPR_20 ListBase(const ListBase<Type>& flag, const FlagType&... flags) {
			add_flags(flag);
			(add_flags(flags), ...);
		}

		/// ListBase Operators ///

		_CONSTEXPR_20 void operator=(const ListBase<Type>& other) {
			if (this != &other) {
				m_flags = other.m_flags;
			}
		}

		_CONSTEXPR_20 void operator=(ListBase<Type>&& other) {
			if (this != &other) {
				m_flags = std::move(other.m_flags);
			}
		}

		_CONSTEXPR_20 ListBase operator+(const ListBase<Type>& other) {
			ListBase new_list(*this);
			new_list += other;
			return new_list;
		}

		_CONSTEXPR_20 ListBase operator+(const Type& flag) {
			ListBase new_list(*this);
			new_list += flag;
			return new_list;
		}

		_CONSTEXPR_20 void operator+=(const ListBase<Type>& other) { m_flags.insert(m_flags.end(), other.m_flags.begin(), other.m_flags.end()); }
		_CONSTEXPR_20 void operator+=(const Type& flag) { m_flags.push_back(flag); }
		_CONSTEXPR_20 void operator+=(Type&& flag) { m_flags.push_back(std::move(flag)); }

		/// End ListBase Operators ///

		_CONSTEXPR_20 std::vector<Type>& get() { return m_flags; }
		_CONSTEXPR_20 const std::vector<Type>& get() const { return m_flags; }
		_CONSTEXPR_20 auto begin() { return m_flags.begin(); }
		_CONSTEXPR_20 const auto begin() const { return m_flags.begin(); }
		_CONSTEXPR_20 auto end() { return m_flags.end(); }
		_CONSTEXPR_20 const auto end() const { return m_flags.end(); }
		_CONSTEXPR_20 std::size_t size() { return m_flags.size(); }
		_CONSTEXPR_20 const std::size_t size() const { return m_flags.size(); }
	private:
		_CONSTEXPR_20 void add_flags(const Type& flag) { m_flags.push_back(flag); }
		_CONSTEXPR_20 void add_flags(const ListBase<Type>& other) { m_flags.insert(m_flags.end(), other.begin(), other.end()); }
	private:
		_CONSTEXPR_20 std::vector<Type> m_flags;
	};

	using List = ListBase<std::string>;
	using DirectoryList = ListBase<build_path>;

	template<typename T>
	_CONSTEXPR_20 ListBase<T> operator+(const std::string& flag, const ListBase<T>& other) {
		List new_list(flag);
		new_list += other;
		return new_list;
	}

	template<typename T>
	std::ostream& operator<<(std::ostream& os, const ListBase<T>& list) {
		for (const auto& i : list.get()) {
			os << i << ' ';
		}
		return os;
	}

	////////////// Library //////////////
	
	struct ProjectBase;
	using Packages = ListBase<ProjectBase>;

	struct ProjectBase {
		List include_dirs, library_dirs, flags, sources, libraries;
		Packages packages;
		Version version{ 0, 0, 0 };
		std::string name;
		build_path dir{ "." };
	};

	////////////// Library //////////////

	struct Library {
	public:
		using build_type = type;

	public:
		Library(std::filesystem::path location, std::filesystem::path file_name, build_type type) : m_location(location), m_file_name(file_name), m_type(type) {}

		const std::filesystem::path location() const { return m_location; }

		const std::filesystem::path file_name() const { return m_file_name; }

		const build_type type() const { return m_type; }

	private:
		std::filesystem::path m_location;
		std::filesystem::path m_file_name;
		build_type m_type;
	};

}